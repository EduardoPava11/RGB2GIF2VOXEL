// YinVoxel (YXV) Format Library
// Reader/Writer for N×N×N voxel containers

use std::fs::File;
use std::io::{Read, Write, Seek, SeekFrom, BufReader, BufWriter};
use std::path::Path;
use anyhow::{Result, Context, bail};
use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use lz4;
use crc32fast::Hasher;

#[cfg(target_os = "macos")]
use lzfse;

// Include FlatBuffers generated code
// This will be generated by flatc from yinvxl.fbs
#[path = "schemas/yinvxl_generated.rs"]
mod yinvxl_generated;
use yinvxl_generated::yin_voxel::*;

// Constants
const MAGIC: &[u8; 4] = b"YXV\0";
const VERSION: u32 = 1;
const CHUNK_ALIGNMENT: u64 = 64;

// Compression types
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Compression {
    None,
    Lz4,
    Lzfse,
    Zstd,
}

impl From<CompressionType> for Compression {
    fn from(ct: CompressionType) -> Self {
        match ct {
            CompressionType::NONE => Compression::None,
            CompressionType::LZ4 => Compression::Lz4,
            CompressionType::LZFSE => Compression::Lzfse,
            CompressionType::ZSTD => Compression::Zstd,
            _ => Compression::None,
        }
    }
}

// Chunk types
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ChunkType {
    Palette,
    Frame,
    Metadata,
    Thumbnail,
}

// Chunk record (24 bytes)
#[derive(Debug, Clone)]
pub struct ChunkRecord {
    pub chunk_type: ChunkType,
    pub offset: u64,
    pub compressed_size: u32,
    pub uncompressed_size: u32,
    pub checksum: u32,
}

impl ChunkRecord {
    fn read_from<R: Read>(reader: &mut R) -> Result<Self> {
        let type_byte = reader.read_u8()?;
        let chunk_type = match type_byte {
            0 => ChunkType::Palette,
            1 => ChunkType::Frame,
            2 => ChunkType::Metadata,
            3 => ChunkType::Thumbnail,
            _ => bail!("Invalid chunk type: {}", type_byte),
        };

        Ok(ChunkRecord {
            chunk_type,
            offset: reader.read_u64::<LittleEndian>()?,
            compressed_size: reader.read_u32::<LittleEndian>()?,
            uncompressed_size: reader.read_u32::<LittleEndian>()?,
            checksum: reader.read_u32::<LittleEndian>()?,
        })
    }

    fn write_to<W: Write>(&self, writer: &mut W) -> Result<()> {
        let type_byte = match self.chunk_type {
            ChunkType::Palette => 0u8,
            ChunkType::Frame => 1,
            ChunkType::Metadata => 2,
            ChunkType::Thumbnail => 3,
        };

        writer.write_u8(type_byte)?;
        writer.write_u64::<LittleEndian>(self.offset)?;
        writer.write_u32::<LittleEndian>(self.compressed_size)?;
        writer.write_u32::<LittleEndian>(self.uncompressed_size)?;
        writer.write_u32::<LittleEndian>(self.checksum)?;

        // Pad to 24 bytes
        writer.write_all(&[0u8; 3])?;

        Ok(())
    }
}

// YXV Container
pub struct YxvContainer {
    pub dimensions: (u32, u32, u32),  // width, height, depth
    pub palette: Vec<[u8; 3]>,        // RGB palette
    pub frames: Vec<Vec<u8>>,         // Frame data (indexed)
    pub compression: Compression,
}

impl YxvContainer {
    pub fn new(dimensions: (u32, u32, u32)) -> Self {
        YxvContainer {
            dimensions,
            palette: Vec::new(),
            frames: Vec::new(),
            compression: Compression::Lz4,
        }
    }

    // Write to file
    pub fn write_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        // Write magic
        writer.write_all(MAGIC)?;

        // Build FlatBuffers header
        let header_data = self.build_header()?;

        // Write header size and data
        writer.write_u32::<LittleEndian>(header_data.len() as u32)?;
        writer.write_all(&header_data)?;

        let mut chunks = Vec::new();
        let mut current_offset = writer.seek(SeekFrom::Current(0))?;

        // Write palette chunk
        if !self.palette.is_empty() {
            let palette_data = self.encode_palette();
            let compressed = self.compress(&palette_data)?;
            let checksum = calculate_crc32(&compressed);

            chunks.push(ChunkRecord {
                chunk_type: ChunkType::Palette,
                offset: current_offset,
                compressed_size: compressed.len() as u32,
                uncompressed_size: palette_data.len() as u32,
                checksum,
            });

            writer.write_all(&compressed)?;
            current_offset = align_offset(&mut writer, CHUNK_ALIGNMENT)?;
        }

        // Write frame chunks
        for frame in &self.frames {
            let compressed = self.compress(frame)?;
            let checksum = calculate_crc32(&compressed);

            chunks.push(ChunkRecord {
                chunk_type: ChunkType::Frame,
                offset: current_offset,
                compressed_size: compressed.len() as u32,
                uncompressed_size: frame.len() as u32,
                checksum,
            });

            writer.write_all(&compressed)?;
            current_offset = align_offset(&mut writer, CHUNK_ALIGNMENT)?;
        }

        // Write chunk table
        for chunk in &chunks {
            chunk.write_to(&mut writer)?;
        }

        writer.flush()?;
        Ok(())
    }

    // Read from file
    pub fn read_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let file = File::open(path)?;
        let mut reader = BufReader::new(file);

        // Read and verify magic
        let mut magic = [0u8; 4];
        reader.read_exact(&mut magic)?;
        if &magic != MAGIC {
            bail!("Invalid YXV file magic");
        }

        // Read header
        let header_size = reader.read_u32::<LittleEndian>()?;
        let mut header_data = vec![0u8; header_size as usize];
        reader.read_exact(&mut header_data)?;

        // Parse header with FlatBuffers
        let header = flatbuffers::root::<VoxelHeader>(&header_data)
            .context("Failed to parse FlatBuffers header")?;

        // Extract dimensions
        let dims = header.dimensions()
            .context("Missing dimensions in header")?;
        let dimensions = (
            dims.get(0) as u32,
            dims.get(1) as u32,
            dims.get(2) as u32,
        );

        // Extract compression
        let compression = Compression::from(header.compression());

        // Read chunk table (simplified for now)
        // In production, read from header.chunk_table_offset()

        let mut container = YxvContainer::new(dimensions);
        container.compression = compression;

        Ok(container)
    }

    // Build FlatBuffers header
    fn build_header(&self) -> Result<Vec<u8>> {
        let mut builder = flatbuffers::FlatBufferBuilder::new();

        // Create dimensions vector
        let dims = builder.create_vector(&[
            self.dimensions.0 as u16,
            self.dimensions.1 as u16,
            self.dimensions.2 as u16,
        ]);

        // Create header
        let header = VoxelHeader::create(&mut builder, &VoxelHeaderArgs {
            version: Some(VERSION),
            dimensions: Some(dims),
            color_mode: ColorMode::INDEXED,
            palette_size: self.palette.len() as u16,
            compression: match self.compression {
                Compression::None => CompressionType::NONE,
                Compression::Lz4 => CompressionType::LZ4,
                Compression::Lzfse => CompressionType::LZFSE,
                Compression::Zstd => CompressionType::ZSTD,
            },
            chunk_count: (1 + self.frames.len()) as u32,  // palette + frames
            chunk_table_offset: 0,  // Will be set later
            view_hints: None,
            creator: Some(builder.create_string("yinvxl-rs")),
            creation_timestamp: Some(std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs()),
            frame_rate: 30,
            metadata: None,
        });

        builder.finish(header, None);
        Ok(builder.finished_data().to_vec())
    }

    // Encode palette
    fn encode_palette(&self) -> Vec<u8> {
        let mut data = Vec::with_capacity(self.palette.len() * 3);
        for color in &self.palette {
            data.extend_from_slice(color);
        }
        data
    }

    // Compression
    fn compress(&self, data: &[u8]) -> Result<Vec<u8>> {
        match self.compression {
            Compression::None => Ok(data.to_vec()),
            Compression::Lz4 => {
                let compressed = lz4::block::compress(data, None, false)?;
                Ok(compressed)
            }
            #[cfg(target_os = "macos")]
            Compression::Lzfse => {
                // Use lzfse crate on macOS
                Ok(lzfse::encode(data))
            }
            #[cfg(not(target_os = "macos"))]
            Compression::Lzfse => {
                bail!("LZFSE compression not available on this platform")
            }
            Compression::Zstd => {
                #[cfg(any(target_os = "windows", target_os = "linux"))]
                {
                    Ok(zstd::encode_all(data, 3)?)
                }
                #[cfg(not(any(target_os = "windows", target_os = "linux")))]
                {
                    bail!("ZSTD compression not available on this platform")
                }
            }
        }
    }

    // Decompression
    fn decompress(&self, data: &[u8], expected_size: usize) -> Result<Vec<u8>> {
        match self.compression {
            Compression::None => Ok(data.to_vec()),
            Compression::Lz4 => {
                let decompressed = lz4::block::decompress(data, Some(expected_size as i32))?;
                Ok(decompressed)
            }
            #[cfg(target_os = "macos")]
            Compression::Lzfse => {
                Ok(lzfse::decode(data))
            }
            #[cfg(not(target_os = "macos"))]
            Compression::Lzfse => {
                bail!("LZFSE decompression not available on this platform")
            }
            Compression::Zstd => {
                #[cfg(any(target_os = "windows", target_os = "linux"))]
                {
                    Ok(zstd::decode_all(data)?)
                }
                #[cfg(not(any(target_os = "windows", target_os = "linux")))]
                {
                    bail!("ZSTD decompression not available on this platform")
                }
            }
        }
    }
}

// Utility functions

fn calculate_crc32(data: &[u8]) -> u32 {
    let mut hasher = Hasher::new();
    hasher.update(data);
    hasher.finalize()
}

fn align_offset<W: Write + Seek>(writer: &mut W, alignment: u64) -> Result<u64> {
    let current = writer.seek(SeekFrom::Current(0))?;
    let padding = (alignment - (current % alignment)) % alignment;

    if padding > 0 {
        writer.write_all(&vec![0u8; padding as usize])?;
    }

    Ok(writer.seek(SeekFrom::Current(0))?)
}

// FFI exports for iOS/macOS integration
#[cfg(feature = "ffi")]
mod ffi {
    use super::*;
    use std::ffi::{CStr, CString};
    use std::os::raw::{c_char, c_void};

    #[no_mangle]
    pub extern "C" fn yxv_write(
        path: *const c_char,
        voxel_data: *const u8,
        voxel_size: usize,
        width: u32,
        height: u32,
        depth: u32,
        palette: *const u8,
        palette_size: u32,
    ) -> i32 {
        // Implementation for FFI write
        0
    }

    #[no_mangle]
    pub extern "C" fn yxv_read(
        path: *const c_char,
        out_container: *mut c_void,
    ) -> i32 {
        // Implementation for FFI read
        0
    }
}