// YinVoxel (YXV) Zig Implementation
// Reader/Writer using C++ FlatBuffers runtime

const std = @import("std");
const c = @cImport({
    // Include FlatBuffers C++ headers
    @cInclude("flatbuffers/flatbuffers.h");
    @cInclude("yinvxl_generated.h");  // Generated by flatc --cpp

    // Include compression libraries
    @cInclude("lz4.h");
});

// Constants
const MAGIC: [4]u8 = .{ 'Y', 'X', 'V', 0 };
const VERSION: u32 = 1;
const CHUNK_ALIGNMENT: u64 = 64;

// Error types
const YXVError = error{
    InvalidMagic,
    UnsupportedVersion,
    CompressionFailed,
    DecompressionFailed,
    ChecksumMismatch,
    InvalidChunkRecord,
    FileNotFound,
    WriteFailed,
};

// Compression types
const CompressionType = enum(u8) {
    none = 0,
    lz4 = 1,
    lzfse = 2,
    zstd = 3,
};

// Chunk types
const ChunkType = enum(u8) {
    palette = 0,
    frame = 1,
    metadata = 2,
    thumbnail = 3,
};

// Chunk record structure (24 bytes)
const ChunkRecord = struct {
    chunk_type: ChunkType,
    offset: u64,
    compressed_size: u32,
    uncompressed_size: u32,
    checksum: u32,
    _padding: [3]u8 = .{ 0, 0, 0 },

    pub fn write(self: ChunkRecord, writer: anytype) !void {
        try writer.writeByte(@enumToInt(self.chunk_type));
        try writer.writeIntLittle(u64, self.offset);
        try writer.writeIntLittle(u32, self.compressed_size);
        try writer.writeIntLittle(u32, self.uncompressed_size);
        try writer.writeIntLittle(u32, self.checksum);
        try writer.writeAll(&self._padding);
    }

    pub fn read(reader: anytype) !ChunkRecord {
        const type_byte = try reader.readByte();
        return ChunkRecord{
            .chunk_type = @intToEnum(ChunkType, type_byte),
            .offset = try reader.readIntLittle(u64),
            .compressed_size = try reader.readIntLittle(u32),
            .uncompressed_size = try reader.readIntLittle(u32),
            .checksum = try reader.readIntLittle(u32),
            ._padding = .{ 0, 0, 0 },
        };
    }
};

// YXV Container
pub const YXVContainer = struct {
    allocator: std.mem.Allocator,
    dimensions: struct { width: u32, height: u32, depth: u32 },
    palette: []const [3]u8,
    frames: []const []const u8,
    compression: CompressionType,

    pub fn init(allocator: std.mem.Allocator) YXVContainer {
        return .{
            .allocator = allocator,
            .dimensions = .{ .width = 0, .height = 0, .depth = 0 },
            .palette = &.{},
            .frames = &.{},
            .compression = .lz4,
        };
    }

    pub fn deinit(self: *YXVContainer) void {
        if (self.palette.len > 0) {
            self.allocator.free(self.palette);
        }
        for (self.frames) |frame| {
            self.allocator.free(frame);
        }
        if (self.frames.len > 0) {
            self.allocator.free(self.frames);
        }
    }

    // Read YXV file
    pub fn readFile(allocator: std.mem.Allocator, path: []const u8) !YXVContainer {
        const file = try std.fs.cwd().openFile(path, .{});
        defer file.close();

        var reader = file.reader();

        // Read and verify magic
        var magic: [4]u8 = undefined;
        _ = try reader.read(&magic);
        if (!std.mem.eql(u8, &magic, &MAGIC)) {
            return YXVError.InvalidMagic;
        }

        // Read header size
        const header_size = try reader.readIntLittle(u32);

        // Read header data
        const header_data = try allocator.alloc(u8, header_size);
        defer allocator.free(header_data);
        _ = try reader.read(header_data);

        // Parse FlatBuffers header using C++ runtime
        // const header = c.YinVoxel_GetVoxelHeader(header_data.ptr);

        // For now, create a dummy container
        var container = YXVContainer.init(allocator);

        // TODO: Parse header and read chunks

        return container;
    }

    // Write YXV file
    pub fn writeFile(self: *const YXVContainer, path: []const u8) !void {
        const file = try std.fs.cwd().createFile(path, .{});
        defer file.close();

        var writer = file.writer();

        // Write magic
        try writer.writeAll(&MAGIC);

        // Build FlatBuffers header
        const header_data = try self.buildHeader();
        defer self.allocator.free(header_data);

        // Write header size and data
        try writer.writeIntLittle(u32, @intCast(u32, header_data.len));
        try writer.writeAll(header_data);

        var chunks = std.ArrayList(ChunkRecord).init(self.allocator);
        defer chunks.deinit();

        var current_offset = try file.getPos();

        // Write palette chunk
        if (self.palette.len > 0) {
            const palette_data = try self.encodePalette();
            defer self.allocator.free(palette_data);

            const compressed = try self.compress(palette_data);
            defer self.allocator.free(compressed);

            const checksum = calculateCRC32(compressed);

            try chunks.append(.{
                .chunk_type = .palette,
                .offset = current_offset,
                .compressed_size = @intCast(u32, compressed.len),
                .uncompressed_size = @intCast(u32, palette_data.len),
                .checksum = checksum,
            });

            try writer.writeAll(compressed);
            current_offset = try alignFile(file, CHUNK_ALIGNMENT);
        }

        // Write frame chunks
        for (self.frames) |frame| {
            const compressed = try self.compress(frame);
            defer self.allocator.free(compressed);

            const checksum = calculateCRC32(compressed);

            try chunks.append(.{
                .chunk_type = .frame,
                .offset = current_offset,
                .compressed_size = @intCast(u32, compressed.len),
                .uncompressed_size = @intCast(u32, frame.len),
                .checksum = checksum,
            });

            try writer.writeAll(compressed);
            current_offset = try alignFile(file, CHUNK_ALIGNMENT);
        }

        // Write chunk table
        for (chunks.items) |chunk| {
            try chunk.write(writer);
        }
    }

    // Build FlatBuffers header
    fn buildHeader(self: *const YXVContainer) ![]u8 {
        // TODO: Use FlatBuffers C++ API via @cImport
        // For now, return a dummy header
        var header = try self.allocator.alloc(u8, 64);
        @memset(header, 0);

        // Write basic info
        std.mem.writeIntLittle(u32, header[0..4], VERSION);
        std.mem.writeIntLittle(u16, header[4..6], @intCast(u16, self.dimensions.width));
        std.mem.writeIntLittle(u16, header[6..8], @intCast(u16, self.dimensions.height));
        std.mem.writeIntLittle(u16, header[8..10], @intCast(u16, self.dimensions.depth));

        return header;
    }

    // Encode palette
    fn encodePalette(self: *const YXVContainer) ![]u8 {
        const data = try self.allocator.alloc(u8, self.palette.len * 3);
        for (self.palette) |color, i| {
            data[i * 3] = color[0];
            data[i * 3 + 1] = color[1];
            data[i * 3 + 2] = color[2];
        }
        return data;
    }

    // Compression
    fn compress(self: *const YXVContainer, data: []const u8) ![]u8 {
        switch (self.compression) {
            .none => {
                const copy = try self.allocator.alloc(u8, data.len);
                std.mem.copy(u8, copy, data);
                return copy;
            },
            .lz4 => {
                const max_size = c.LZ4_compressBound(@intCast(c_int, data.len));
                const compressed = try self.allocator.alloc(u8, @intCast(usize, max_size));

                const compressed_size = c.LZ4_compress_default(
                    data.ptr,
                    compressed.ptr,
                    @intCast(c_int, data.len),
                    @intCast(c_int, max_size),
                );

                if (compressed_size <= 0) {
                    self.allocator.free(compressed);
                    return YXVError.CompressionFailed;
                }

                // Resize to actual size
                const result = try self.allocator.realloc(compressed, @intCast(usize, compressed_size));
                return result;
            },
            else => return YXVError.CompressionFailed,
        }
    }

    // Decompression
    fn decompress(self: *const YXVContainer, data: []const u8, expected_size: usize) ![]u8 {
        switch (self.compression) {
            .none => {
                const copy = try self.allocator.alloc(u8, data.len);
                std.mem.copy(u8, copy, data);
                return copy;
            },
            .lz4 => {
                const decompressed = try self.allocator.alloc(u8, expected_size);

                const result = c.LZ4_decompress_safe(
                    data.ptr,
                    decompressed.ptr,
                    @intCast(c_int, data.len),
                    @intCast(c_int, expected_size),
                );

                if (result < 0) {
                    self.allocator.free(decompressed);
                    return YXVError.DecompressionFailed;
                }

                return decompressed;
            },
            else => return YXVError.DecompressionFailed,
        }
    }
};

// Utility functions

fn calculateCRC32(data: []const u8) u32 {
    // Simple CRC32 implementation or use a library
    // For now, return a simple checksum
    var sum: u32 = 0;
    for (data) |byte| {
        sum = sum +% byte;
    }
    return sum;
}

fn alignFile(file: std.fs.File, alignment: u64) !u64 {
    const current = try file.getPos();
    const padding = (alignment - (current % alignment)) % alignment;

    if (padding > 0) {
        const zeros = [_]u8{0} ** 64;
        try file.writer().writeAll(zeros[0..padding]);
    }

    return try file.getPos();
}

// Test
test "YXV basic operations" {
    const allocator = std.testing.allocator;

    var container = YXVContainer.init(allocator);
    defer container.deinit();

    container.dimensions = .{ .width = 132, .height = 132, .depth = 132 };

    // Test chunk record serialization
    const chunk = ChunkRecord{
        .chunk_type = .frame,
        .offset = 1024,
        .compressed_size = 256,
        .uncompressed_size = 512,
        .checksum = 0x12345678,
    };

    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    try chunk.write(buffer.writer());
    try std.testing.expectEqual(@as(usize, 24), buffer.items.len);
}